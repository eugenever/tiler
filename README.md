# Приложение на базе Rust и Python для построения пирамид тайлов и генерации динамических тайлов (on-fly)

## Зависимости

1. `GDAL` используется из состава общего дистрибутива `MapServer`, например:

- https://www.gisinternals.com/query.html?content=filelist&file=release-1930-x64-gdal-3-8-4-mapserver-8-0-1.zip
- https://download.gisinternals.com/sdk/downloads/release-1930-x64-gdal-3-8-4-mapserver-8-0-1.zip
- https://download.gisinternals.com/sdk/downloads/release-1930-x64-gdal-3-8-4-mapserver-8-0-1-libs.zip

Рекомендуемые версии `GDAL`: 3.8.\*.
Ошибки на версиях 3.6-3.8 на ряде растров связаны с оригинальным алгоритмом gdal2tiles (исправлено).
`PROJ` поставляется в составе общего дистрибутива `MapServer/GDAL`.
Последние версии питоновской библиотеки `rasterio` требуют `PROJ` версии `PROJ9`, которую можно взять из состава `GDAL` версии 3.8.

Переменные окружения (пример):

```
POLARS_SKIP_CPU_CHECK: 1
GDAL_HOME: C:\Projects\lib\GDAL-381
PROJ_LIB: C:\Projects\lib\GDAL-381\bin\proj9\share
PYTHONPATH=C:/Projects/lib/python3118_gdal381
PATH:
    - C:\Projects\lib\python3118_gdal381
    - C:\Projects\lib\python3118_gdal381\Scripts
    - C:\Projects\lib\GDAL-381\bin
    - C:\Projects\lib\GDAL-381\bin\gdal\apps
```

Указанные выше переменные окружения загружаются из файла `.env` (находится в корневой папке приложения) и передаются
в воркеры `Python`. За исключением переменной `POLARS_SKIP_CPU_CHECK` и пути к интерпретаору.

Для запуска сервисных скриптов на `Python` необходимо определить в системе путь к интепретатору. Для этого в `Path`
добавить, например, путь `C:\Projects\lib\python3118_gdal381`.

2. Рекомендуется `Python версий 3.10.13, 3.11.5, 3.11.8`. Указанные версии 3.11 имеют исправленные баги и улучшенную
   производительность по сравнению с 3.10 на 10-15%.

Переменные окружения (пример):

```
PYTHONPATH:
    - C:\Projects\lib\python3118_gdal381
    - C:\Projects\lib\python3118_gdal381\Scripts
PATH:
    - C:\Projects\lib\python3118_gdal381
    - C:\Projects\lib\python3118_gdal381\Scripts
    - C:\Projects\lib\GDAL-381\bin
    - C:\Projects\lib\GDAL-381\bin\gdal\apps
```

3. Основные библиотеки `Python` (в том числе общей направленности):

   - affine==2.4.0
   - aiofiles==23.2.1
   - aiosqlite==0.19.0
   - arrayfire==3.8.0
   - afnumpy==1.3.0 (для интеграции массивов AF и NumPy)
   - bestconfig==1.3.6
   - FastAPI==0.111.0
   - GDAL==3.8.1 (3.8.3, 3.8.4)
   - Granian==2.2.0 (1.5.2)
   - Nuitka==2.3.11 (для Windows MSVC 14.3)
   - numpy==1.26.4
   - numba==0.60.0 (для акселерации NumPy)
   - orjson==3.10.0
   - llvmlite==0.43.0
   - maturin==1.4.0 (для сборки воркеров Robyn)
   - morecantile==5.3.0
   - pillow==10.2.0
   - psutil==5.9.8
   - pyproj==3.6.1
   - rasterio==1.3.9
   - rio-tiler==6.4.1
   - starlette==0.36.3
   - uvloop==0.19.0 (event loop asyncio для Unix)
   - winloop==0.1.3 (event loop asyncio для Windows)

## HTTP Сервер

При большом числе конкурентных запросов (подключений) в ОС необходимо увеличить допустимое число одновременно открытых файлов. Для тестовых целей это можно сделать в терминале перед запуском гео-сервера, например, в Linux командой:
```
ulimit -n 131136
```

В первой версии сервера на базе связки `FastAPI` и `Uvicorn` (чистый Python) имелись ряд проблем, одна из которых критическая:

- на ОС `Windows` происходило преждевременное закрытие сокета с ошибкой `[WinError 64]`. В попытках остаться в рамках языка
  `Python` были протестированы сервер `hypercorn`, а также синхронный фреймворк `Flask`. Указанная ошибка повторялась в новом
  окружении на основе этих модулей. Ошибка относится к сетевому стеку вцелом интерпретатора `Python`.
- сервер `Uvicorn` имеет не оптимальный алгоритм распределения запросов между своими воркерами для задач класса
  `CPU-bound`. На практике получалось, что часть воркеров сильно загружена запросами генерации тайлов, а другая часть может
  быть не задействована.
- низкая производительность асинхронных библиотек (особенно на ОС Windows, где `asyncio` имеет нативную реализацию на Python).
- отсутствие достаточного уровня синхронизации процессов воркеров http-сервера.
- большое потребление оперативной памяти воркерами `Python` на простых IO операциях.

В текущей реализации сервера указанные выше проблемы решены. Недостатком данного варианта является сложность
архитектуры приложения, его поддержки, необходимость владеть языками `Python`, `Rust` и определенными их библиотеками. Однако
большая часть логики должна реализовываться на `Python` так как слой на `Rust` обеспечивает транспортный уровень и забирает
на себя большой объём IO операций. Существующий код на `Rust` не будет претерпевать изменений, за исключением потребностей в
в узконаправленных оптимизациях. Таким образом, можно привлекать в проект разработчиков на `Python`.

- прокси-сервер, балансировщик запросов, модуль управления состоянием тайлов, модуль мультипроцессинга (реализован на `Rust`):
  [proxy balancer](https://github.com/eugenever/tiler/tree/main/server/rust/proxy-balancer)

- минималистичный http-сервер для web-приложений на `Python` (реализован на `Rust`, фреймворк `Actix`). Использует библиотеку
  `PyO3` для взаимодествия с `API Python`:
  [robyn rust worker](https://github.com/eugenever/tiler/tree/main/server/rust/robyn-worker)

- http-сервер [Granian](https://github.com/emmett-framework/granian) с полноценной поддержкой `ASGI` и, соответственно, `FastAPI` (на основе `hyper`)

- целевое приложение на `Python`, которое загружается в воркеры http-сервера - [app_granian](https://github.com/eugenever/tiler/blob/main/app_granian.py) или [app_robyn](https://github.com/eugenever/tiler/blob/main/app_robyn.py)

Текущая реализация обеспечивает одинаковый высокий уровень производительности на `Unix` и `Windows` системах, предоставляет
больше настроек и даёт больше контроля над процессами приложения (воркерами процессов `Python`).

## Основной функционал приложения

1. Препроцессинг исходного растра:

   - `gdalwarp`: выполнение необходимых трансформаций (опционально)
   - `gdal_translate`: перенарезка внутренних блоков растра по размеру базового тайла (обычно `256 x 256`) и
     внутренний тайлинг
   - `gdaladdo`: генерация `внешних overviews` для оптимизации извлечения динамических тайлов

2. Генерация пирамид тайлов (автоматически запускает `п.1`). Выполняем следующие `post` запросы на `/api/pyramid`:

```
    curl -X "POST" \
    "http://localhost:8000/api/pyramid" \
    -H "accept: application/json" \
    -H "Content-Type: application/json" \
    -d "{
        "datasource_id": "dafc76d4-8bc7-455a-a2d4-4e2d1cb13b35",
        "scheduled_for": "2024-08-18T01:30:00+04:00" // опционально
    }"
```

Параметр `datasource_id` соответствует полю `id` из датасорса. Датасорсы при первоначальной инициализации базы данных
располагаются в директориях [datasources/raster](https://github.com/eugenever/tiler/tree/main/datasources/raster) и [datasources/vector](https://github.com/eugenever/tiler/tree/main/datasources/vector).
Предполагается, что исходный растр размещается в папке `{Tiler_App}/data`, например:

- C:\TileServer\data\Telekom_Srbija_2G_bounded_in_dBm_2020Q3.TIF
- C:\TileServer\data\mosaics\coverage_mosaics\

В качестве ответа приходит `json` с `id` задачи/пирамиды (`{"id": "c28ce90c-1882-480c-8352-3caf62f83bb3"}`), запущенной
на выполнение.

Пирамиды сохраняются в следующих вариантах:

- в рамках папок файловой системы по схеме `{Tiler_App}/tiles/{datasource_id}/{z}/{x}/{y}.png`, параметр `"mbtiles": "false"`
- в базе данных `SQLite` - `{Tiler_App}/tiles/{datasource_id}/{datasource_id}.mbtiles`, параметр `"mbtiles": "true"`

Сервер не допускает генерацию двух пирамид для одного и того же растра в один момент времени.
Это защита от повторных ошибочных запросов со стороны клиента на генерацию пирамид, которые уже находятся
в запущенном состоянии. Сервер вернет `id` выполняющейся пирамиды для указанного `datasource_id`.

3. Генерация динамических растровых тайлов. Указанный функционал доступен только после завершения этапа препроцессинга
   исходного растра из `п.1`.

Выполняется `get` запрос на `/api/tile/{datasource_id}/{z}/{x}/{y}.{ext}`, например (одиночные растры и мозаики):

```
http://localhost:8000/api/tile/dafc76d4-8bc7-455a-a2d4-4e2d1cb13b35/5/17/11.png
http://localhost:8000/api/tile/dafc76d4-8bc7-455a-a2d4-4e2d1cb13b35/10/565/365.png
http://localhost:8000/api/tile/dafc76d4-8bc7-455a-a2d4-4e2d1cb13b35/9/286/189.png
```

При выполнении запроса `до завершения п.1` возвращается ошибка, как вариант код `500`. На данном этапе ещё отсутствует
подготовленный растр для извлечения динамических тайлов.

4. Генерация динамических векторных тайлов, в общем случае, не требует препроцессинга как в случае с растрами.
   Препроцессинг векторных данных выполняется на стадии подготовки схемы базы данных до установки на сервера заказчика.
   То есть векторные слои должны быть оптимизированы до введения приложения в эксплуатацию.

Выполняется `get` запрос на `/api/tile/{datasource_id}/{z}/{x}/{y}.{ext}`, например:

```
http://localhost:8000/api/tile/aa274ed8-f592-4a74-bfed-ef56cbdbcd10/11/1234/629.mvt
http://localhost:8000/api/tile/e000dfde-5c30-4783-b8f5-d3ae3138ad39/11/1135/735.pbf
```

5. Сервер позволяет параллельно генерировать пирамиды для разных растров и выполнять для них запросы
   по извлечению динамических тайлов. Важно отметить, что нельзя допускать превышения числа воркеров над числом ядер процессора.

Например, процессор имеет 20 ядер. Количество растров для параллельной генерации пирамид в один момент времени - 5.
Для каждой пирамиды мы указываем в датасорсе параметр `count_processes`, который определяет количество процессов/ядер для её генерации. Необходимо выбирать указанный параметр так чтобы в сумме все пирамиды `не утилизировали` все ядра. Всегда должны оставаться ядра под процессы сервера и генерацию динамических тайлов. Нужно использовать вариант с понижением приоритета пирамид перед динамическим тайлингом. В указанном примере можно использовать пропорции 5 ядер на пирамиды и 15 ядер для динамических тайлов.
