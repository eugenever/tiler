# Генерация пирамид тайлов и динамических тайлов

Данный функционал представлен кодом на языке `Python`. Главная причина использования указанного языка - наличие необходимых
библиотек для обработки растров и математических расчетов.
Рекомендуемые версии `Python` протестированные на ОС Windows, Linux и показывающие разумную производительность:

- 3.10.13
- 3.11.5
- 3.11.8

Основные зависимости и модули по обработке растров (растры и векторные данные):

- GDAL 3.8.1, 3.8.3, 3.8.5
- rasterio 1.3.9
- rio-tiler 6.4.1
- morecantile 5.3.0
- numpy 1.26.4
- numba 0.60.0 (для акселерации NumPy)
- asyncpg 0.29.0 (клиент для подключения к PostgreSQL)

Основное программное обеспечение для обработки векторных данных:

- PostgreSQL 16.x
- PostGIS 3.4

`Важно` для обеспечения воспроизводимости результатов (например, тайлов) не обновлять установленные зависимости из числа
вышеперечисленных. На форумах и гитхабе встречаются нарекания, что после обновления даже патч-версий бибилотек
результаты обработки растров отличаются от тех что были ранее. Этот факт признаётся разработчиками GDAL`а и rasterio и
рекомендуют фиксировать версии модулей.

Сервис обеспечивает тайлинг растров для следующих исходных данных:

- одиночные картографические растры без кодирования в RGBA. Это любые растры в формате GeoTIFF.
- одиночные растры с одним бандом со свойством `ColorInterp` в значении `Gray` с кодированием в RGBA
- мозаика растров с одним бандом со свойством `ColorInterp` в значении `Gray` кодированием в RGBA

Требования к исходным растрам:

- наличие данных о `геопривязке` (extent, bounds)
- наличие значений `NODATA` (в противном случае будет использоваться нуль, что может быть некорректно)
- для мозаик растры должны иметь почти `одинаковое разрешение` для избежания перекрытия пикселей

Исходные одиночные растры размещаются в папке `data`, например:

```
- C:\TileServer\data\Telekom_Srbija_2G_bounded_in_dBm_2020Q3.TIF
- C:\TileServer\data\earth_2400.tiff
```

Результаты препроцессинга одиночных растров и мозаик будут сохранены в директории с именем `datasource_id`:

```
- C:\TileServer\data\{datasource_id}
```

Исходные растры-ассеты мозаик размещаются в отдельных папках внутри директории `{Tiler_App}/data/mosaics`, например:

- C:\TileServer\data\mosaics\coverage_mosaics\
- C:\TileServer\data\mosaics\Serbija\
- C:\TileServer\data\mosaics\Moscow_terrain\

Результаты тайлинга в обоих случаях сохраняются в директориях по шаблону `{Tiler_App}/tiles/{datasource_id}/{z}/{x}/{y}.{ext}` или
в формате `MBTiles` - `{Tiler_App}/tiles/{datasource_id}/{datasource_id}.mbtiles`

Во всех случаях к результатам `препроцессинга` растров относятся следующие данные:

- промежуточные и итоговые растры прошедшие стадии `gdalwarp, gdal_translate и gdaladdo`. Указанные преобразования предназначены
  для приведения CRS к `EPSG:3857`, создания `внутреннего тайлинга` растра с заданными размерами блоков и генерации
  `внешних overviews`
- файл с расширением `db` и именем исходного растра/мозаики. Содержит информацию о детализации тайлов по результатам
  анализа исходного растра/мозаики, параметры генерации пирамиды тайлов (для синхронизации с динамическим тайлингом),
  перечень "пустых" тайлов для избежания повторных запросов за ними в код на `Python`.

После завершения препроцессинга выполняется стадия `тайлинга` (пирамида и динамика), которая на выходе даёт
следующие данные:

- опционально набор папок с именами представляющими `zoom`, далее внутри папки с индексами по оси `X` и внутри них сами файлы
  тайлов с именами индексов по оси `Y` и расширением `png`.
- опционально файл с расширением `mbtiles` и именем исходного растра/мозаики. Представляет собой базу данных тайлов
  в формате `MBTiles`.

## Примеры запросов генерации пирамид тайлов и динамических тайлов

Для запуска генерации пирамид тайлов (растры и векторные данные) используются POST запросы следующего вида:

```
curl -X 'POST' \
  'http://localhost:8000/api/pyramid' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
	  "datasource_id": "b79955e9-70d7-40ff-b3f8-5fb944078059"
}'
```

Параметры настроек пирамид тайлов растров из датасорсов:

- `verbose`: False (режим debug отключен)
- `profile`: по умолчанию "mercator"
- `resampling`: метод ресэмплинга при генерации тайла, по умолчанию "average"
- `tiledriver`: драйвер используемый при генерации тайлов, по умолчанию "PNG"
- `tile_size`: размер тайла, по умолчанию 256 (оптимально для производительности)
- `XYZ`: схема генерации тайлов XYZ или TMS, по умолчанию True (индексация по Y в формате XYZ, при False в формате TMS)
- `datasource_id`: идентификатор датасорса (поле 'id' датасорса)
- `count_processes`: число процессов для генерации тайлов, по умоланию равно числу ядер процессора (рекомендуется ограничивать)
- `minzoom`: минимальный порог зума до которого будет строится пирамида
- `maxzoom`: максимальный порог зума до которого будет строится пирамида
- `mbtiles`: сохранять сгенерированные тайлы в БД SQLite в формате mbtiles, по умолчанию True (при False тайлы сохраняются
  в рамках папок файловой системы)
- `warnings`: выводить в терминал предупреждения от библиотек (GDAL, Rio-Tiler), по умолчанию False
- `save_tile_detail_db`: сохранять результаты препроцессинга в БД SQLite, по умолчанию True
- `warp`: запускать варпинг исходного GeoTIFF для улучшения разрешения, по умолчанию False
- `resampling_warp`: метод ресэмплинга при варпинге, по умолчанию "average"
- `remove_processing_raster_files`: удалять результаты препроцессинга после генерации пирамиды, по умолчанию False
- `encode_to_rgba`: кодировать исходный одноканальный GeoTIFF в RGBA, по умолчанию True
- `nodata_default`: дефолтное значение nodata если последняя не задана в растре, по умолчанию -999999
- `pixel_selection_method`: метод выбора итогового пикселя при тайлинге мозаик, по умолчаннию "FirstMethod"
- `merge`: выполнять слияние мозаик в один растр перед тайлингом, по умолчанию True

Допустимые значения для отдельных параметров:

- profile: "mercator"
- resampling: "nearest", "average", "bilinear", "cubic", "cubicspline", "lanczos"
- tiledriver: "PNG"
- pixel_selection_method: "FirstMethod", "HighestMethod", "LowestMethod", "MeanMethod"
- zoom: в диапазоне от 0 до 20
- count_processes: в диапазоне от 1 до 2\*CPU

Для генерации динамических тайлов используются следующие get-запросы (http://localhost:8000/api/tile/{datasource_id}/{z}/{x}/{y}.png):

```
http://localhost:8000/api/tile/dafc76d4-8bc7-455a-a2d4-4e2d1cb13b35/5/17/11.png
http://localhost:8000/api/tile/aa274ed8-f592-4a74-bfed-ef56cbdbcd10/10/565/365.mvt
http://localhost:8000/api/tile/939b9858-4d92-4757-b46a-0419358c9025/9/286/189.pbf
```

Запросы на генерацию пирамид выполняются по требованию конечных пользователей приложения из UI.
Запросы динамических тайлов выполняются автоматически клиентскими картографическими бибилотеками. Примеры интеграции с
библиотекой `MapLibre GL JS` версии 4.1.2 представленый в папке [raster_tiles/tests/maplibre](https://gitlab.isone.com/aspect/aspect-gis/-/tree/develop/Tiler-Rust/raster_tiles/tests/maplibre?ref_type=heads).

## Комментарии к программному коду

Обработка одиночных растров (препроцессинг + построение пирамиды тайлов), главным образом, находится в файле [tiles_processing.py](https://gitlab.isone.com/aspect/aspect-gis/-/blob/develop/Tiler-Rust/raster_tiles/tiles_processing.py?ref_type=heads). Применяется высокроуровневый API библиотеки `rio-tiler`.

Обработка мозаик (препроцессинг + построение пирамиды тайлов) представлена в файле [preprocessing.py](https://gitlab.isone.com/aspect/aspect-gis/-/blob/develop/Tiler-Rust/raster_tiles/mosaic/preprocessing.py?ref_type=heads) и его зависимостях. Для тайлирования мозаик могут использоваться два подхода. Первый применяет API библиотеки `rio-tiler` через stacking массивов всех ассетов мозаики. Главный недостаток данного подхода - большой объём IO-операций и массивов непосредственно в момент тайлинга (внутри endpoint), что приводит к значительным временным задержкам отдачи тайла. Второй подход использует предварительное слияние ассетов мозаик в один итоговый растр на стадии препроцессинга, что разгружает хэндлер, в котором происходит тайлинг. Второй подход обеспечивает достаточную производительность и возможность контроля над слиянием, так как применяются среднеуровневые врапперы из библиотеки `rasterio` над функционалом `GDAL`.

Функционал обработки динамических тайлов представлен в директории [single_tile](https://gitlab.isone.com/aspect/aspect-gis/-/tree/develop/Tiler-Rust/raster_tiles/single_tile?ref_type=heads). Применяется высокроуровневый API библиотеки `rio-tiler`.

От функционала метатайла вынуждено пришлось отказаться. Причина в том, что метатайл имеет динамическое наполнение в
зависимости от последовательности запросов за конкретными целевыми тайлами. Как итог, `GDAL` на основе разных "окон" вычитывания
данных засчет ресэплинга для одного и того же пикселя выдаёт разные значения. Таким образом, не обеспечивается воспроизводимость
результатов тайлинга.

В программном коде `Python` геосервера не используется стандартный модуль `multiprocessing` в виду зависаний и блокировок процессов при их запуске на ОС Linux. Переход на метод `spawn` приводит к иным ошибкам. По этой причине используются отдельные процессы запускаемые вручную и отдельные очереди к этим процессам.

Функционал кодирования массивов растра в RGBA представлен в файле [utils.py](https://gitlab.isone.com/aspect/aspect-gis/-/blob/develop/Tiler-Rust/raster_tiles/utils.py?ref_type=heads) и директории [acceleration](https://gitlab.isone.com/aspect/aspect-gis/-/tree/develop/Tiler-Rust/raster_tiles/acceleration?ref_type=heads). Для ускорения работы базовой версии `NumPy` используется модуль `Numba`. Этот факт приводит к тому, что старт процессов `Python` выполняется медленно, около 7-8 сек, так как происходит JIT компиляция функций вызываемых библиотекой Numba.

## Выводы по результатам нагрузочного тестирования

1. При использовании экземпляра геосервера одновременно для раздачи готовых тайлов и генерации отсутствующих стараться
   не использовать многопоточный режим рантайма Токио в прокси-сервере (балансировщике). При большом объеме запросов за
   готовыми тайлами прокси-сервер утилизирует все ядра процессора не позволяя последнему предоставлять ресурсы воркерам
   Питона, в которых генерируются тайлы. Это приводит к ошибке `Error put tile detail in queue index=0, tz=14, tx=9077, ty=10568`,
   которая говорит о том, что воркер Питона не потребляет задачи на тайлинг из своей очереди (т.к. все ресурсы занял Rust).

2. Не превышать совокупное число доступных ядер процессора при запуске нескольких пирамид одновременно. Это приводит
   к большим задержкам тайлинга даже на небольших растрах и задержкам по остальным "невычислительным" запросам.

3. Не перегружать PostgreSQL большим числом одновременных запросов на генерацию векторных тайлов. При попытке запуска
   нагрузочного скрипта с числом конкурентных запросов 50 в каждый момент времени процесс PostgreSQL/PostGIS падает
   с ошибкой `the database system is in recovery mode`. В таком режиме PostgreSQL пытается запускать тысячи своих воркеров, что,
   скорее всего, не допускает ОС и в итоге наблюдаются ошибки. При этом проводилось тестирование пятикратного превышения
   числа воркеров PostgreSQL над числом ядер (40 против 8), что не привело к ошибкам, но показало значительное потребление
   ресурсов процессора (90-95%) и оперативной памяти (дополнительно ~15% к текущим затратам, ~6 ГБ).

4. Целесообразно запускать несколько экземпляров геосерверов на разных машинах с целью разгрузить главный сервер (мастер)
   от большой нагрузки по тайлингу и уменьшить использование дискового пространства, а также улучшить отклик на запросы.

5. Вынести сервер PostgreSQL на отдельную машину с целью обеспечить векторный тайлинг на собственных вычислительных
   ресурсах, которые не будут использоваться процессами геосервера, выполняющими тайлинг растров. В том числе, это снизит
   вероятность ошибок в воркерах PostgreSQL связанных с недостатком ресурсов оперативной памяти и процессора, что наблюдается
   при нагрузочном тестировании при одновременном запуске нескольких растровых пирамид, средней нагрузке по отдаче готовых
   тайлов и построении одной векторной пирамиды для Центрального Федерального округа.

6. Отдачу готовых тайлов можно выполнять на целевых серверах, где размещается интересуемый DataSource (растр или вектор).
   Производительность отдачи тайлов из базы данных SQLite по показателям виртуальной машины с Windows Server 2022 доведена
   до 8-9 тыс RPS посредством однопоточного процесса на Rust.
